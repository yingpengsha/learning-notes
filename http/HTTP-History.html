<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP 学习笔记（二）：HTTP 协议的发展历史 | 飞行随笔</title>
    <meta name="description" content="yingpengsha 的学习笔记">
    
    
    <link rel="preload" href="/learning-notes/assets/css/0.styles.46b61a67.css" as="style"><link rel="preload" href="/learning-notes/assets/js/app.2cc13775.js" as="script"><link rel="preload" href="/learning-notes/assets/js/9.d53e678f.js" as="script"><link rel="prefetch" href="/learning-notes/assets/js/10.69fcc7e1.js"><link rel="prefetch" href="/learning-notes/assets/js/11.bd59a6f5.js"><link rel="prefetch" href="/learning-notes/assets/js/12.edc4d4f1.js"><link rel="prefetch" href="/learning-notes/assets/js/13.294f7aaa.js"><link rel="prefetch" href="/learning-notes/assets/js/14.6c2f6496.js"><link rel="prefetch" href="/learning-notes/assets/js/15.ab623690.js"><link rel="prefetch" href="/learning-notes/assets/js/16.0f9fc7ee.js"><link rel="prefetch" href="/learning-notes/assets/js/17.53dbf67f.js"><link rel="prefetch" href="/learning-notes/assets/js/2.436be95e.js"><link rel="prefetch" href="/learning-notes/assets/js/3.2cb10772.js"><link rel="prefetch" href="/learning-notes/assets/js/4.a8f0640a.js"><link rel="prefetch" href="/learning-notes/assets/js/5.aff373d7.js"><link rel="prefetch" href="/learning-notes/assets/js/6.e6f09e44.js"><link rel="prefetch" href="/learning-notes/assets/js/7.8cbe0042.js"><link rel="prefetch" href="/learning-notes/assets/js/8.b0fb5279.js">
    <link rel="stylesheet" href="/learning-notes/assets/css/0.styles.46b61a67.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/learning-notes/" class="home-link router-link-active"><!----> <span class="site-name">飞行随笔</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/learning-notes/" class="nav-link">首页</a></div><div class="nav-item"><a href="/learning-notes/about/index.html" class="nav-link">关于我</a></div><div class="nav-item"><a href="https://github.com/yingpengsha" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/learning-notes/" class="nav-link">首页</a></div><div class="nav-item"><a href="/learning-notes/about/index.html" class="nav-link">关于我</a></div><div class="nav-item"><a href="https://github.com/yingpengsha" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>HTTP 学习笔记</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/learning-notes/http/TCPIP.html" class="sidebar-link">TCP/IP 五层模型</a></li><li><a href="/learning-notes/http/HTTP-History.html" class="active sidebar-link">HTTP 协议的发展历史</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#http-0-9" class="sidebar-link">HTTP / 0.9</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#请求格式" class="sidebar-link">请求格式</a></li><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#响应格式" class="sidebar-link">响应格式</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#http-1-0" class="sidebar-link">HTTP / 1.0</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#请求格式-2" class="sidebar-link">请求格式</a></li><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#响应格式-2" class="sidebar-link">响应格式</a></li><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#content-type-字段" class="sidebar-link">Content-Type 字段</a></li><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#content-encoding-字段" class="sidebar-link">Content-Encoding 字段</a></li><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#缺点" class="sidebar-link">缺点</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#http-1-1" class="sidebar-link">HTTP / 1.1</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#持久连接" class="sidebar-link">持久连接</a></li><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#管道机制" class="sidebar-link">管道机制</a></li><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#content-length-字段" class="sidebar-link">Content-Length 字段</a></li><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#分块传输编码" class="sidebar-link">分块传输编码</a></li><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#其他" class="sidebar-link">其他</a></li><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#缺点-2" class="sidebar-link">缺点</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#http-2" class="sidebar-link">HTTP / 2</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#二进制协议" class="sidebar-link">二进制协议</a></li><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#多工" class="sidebar-link">多工</a></li><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#数据流" class="sidebar-link">数据流</a></li><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#头信息压缩" class="sidebar-link">头信息压缩</a></li><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#服务器推送" class="sidebar-link">服务器推送</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning-notes/http/HTTP-History.html#参考链接" class="sidebar-link">参考链接</a></li></ul></li><li><a href="/learning-notes/http/HTTP-Connect.html" class="sidebar-link">HTTP 三次握手和四次挥手</a></li><li><a href="/learning-notes/http/URI-URL-URN.html" class="sidebar-link">URI、URL、URN</a></li><li><a href="/learning-notes/http/HTTP-Message.html" class="sidebar-link">HTTP 报文</a></li><li><a href="/learning-notes/http/HTTP-Code.html" class="sidebar-link">HTTP 状态码</a></li><li><a href="/learning-notes/http/Cross-Domain.html" class="sidebar-link">同源策略</a></li><li><a href="/learning-notes/http/JSONP.html" class="sidebar-link">跨域解决方案：JSONP</a></li><li><a href="/learning-notes/http/CORS.html" class="sidebar-link">跨域解决方案：CORS</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>JS 学习笔记</span> <span class="arrow right"></span></p> <!----></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="http-学习笔记（二）：http-协议的发展历史"><a href="#http-学习笔记（二）：http-协议的发展历史" aria-hidden="true" class="header-anchor">#</a> HTTP 学习笔记（二）：HTTP 协议的发展历史</h1> <p>HTTP 是基于 TCP/IP 协议的<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener noreferrer">应用层协议<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p> <p><a name="8WIb8"></a></p> <h2 id="http-0-9"><a href="#http-0-9" aria-hidden="true" class="header-anchor">#</a> HTTP / 0.9</h2> <p>最早版本是1991年发布的0.9版，该版本极其简单。<a href="https://www.w3.org/Protocols/HTTP/AsImplemented.html" target="_blank" rel="noopener noreferrer">考古链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ol><li>有且只有一个 GET 命令</li> <li>没有HEADER等描述数据的信息</li> <li>服务器发送完数据，就关闭TCP连接</li></ol> <p><a name="fgjy1"></a></p> <h3 id="请求格式"><a href="#请求格式" aria-hidden="true" class="header-anchor">#</a> 请求格式</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /index.html
</code></pre></div><p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页<code>index.html</code>。</p> <p><a name="BSKI7"></a></p> <h3 id="响应格式"><a href="#响应格式" aria-hidden="true" class="header-anchor">#</a> 响应格式</h3> <p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>Hello World<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><a name="Kt8E4"></a></p> <h2 id="http-1-0"><a href="#http-1-0" aria-hidden="true" class="header-anchor">#</a> HTTP / 1.0</h2> <p>1996年5月，HTTP/1.0 版本发布。<a href="https://tools.ietf.org/html/rfc1945" target="_blank" rel="noopener noreferrer">考古链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ol><li>拥有 GET、POST、HEAD 三种命令</li> <li>增加了 status code 和 header</li> <li>多字符集支持、多部分发送、权限、缓存、内容编码等</li></ol> <p><a name="L9m1i"></a></p> <h3 id="请求格式-2"><a href="#请求格式-2" aria-hidden="true" class="header-anchor">#</a> 请求格式</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET / HTTP/1.0
<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
<span class="token header-name keyword">Accept:</span> */*
</code></pre></div><p>第一行是请求命令，必须在尾部添加协议版本（<code>HTTP/1.0</code>）。后面就是多行头信息，描述客户端的情况。</p> <p><a name="6xXWq"></a></p> <h3 id="响应格式-2"><a href="#响应格式-2" aria-hidden="true" class="header-anchor">#</a> 响应格式</h3> <div class="language-http extra-class"><pre class="language-http"><code><span class="token response-status">HTTP/1.0 <span class="token property">200 OK </span></span>
<span class="token header-name keyword">Content-Type:</span> text/plain
<span class="token header-name keyword">Content-Length:</span> 137582
<span class="token header-name keyword">Expires:</span> Thu, 05 Dec 1997 16:00:00 GMT
<span class="token header-name keyword">Last-Modified:</span> Wed, 5 August 1996 15:55:28 GMT
<span class="token header-name keyword">Server:</span> Apache 0.84

&lt;html&gt;
  &lt;body&gt;Hello World&lt;/body&gt;
&lt;/html&gt;
</code></pre></div><p>回应的格式是&quot;头信息 + 一个空行（<code>\r\n</code>） + 数据&quot;。其中，第一行是&quot;协议版本 + 状态码（status code） + 状态描述&quot;。</p> <p><a name="BjFjB"></a></p> <h3 id="content-type-字段"><a href="#content-type-字段" aria-hidden="true" class="header-anchor">#</a> Content-Type 字段</h3> <p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是<code>Content-Type</code>字段的作用。</p> <p>下面是一些常见的<code>Content-Type</code>字段的值。</p> <ul><li>text/plain</li> <li>text/html</li> <li>text/css</li> <li>image/jpeg</li> <li>image/png</li> <li>image/svg+xml</li> <li>audio/mp4</li> <li>video/mp4</li> <li>application/javascript</li> <li>application/pdf</li> <li>application/zip</li> <li>application/atom+xml</li></ul> <p>这些数据类型总称为<code>MIME type</code>，每个值包括一级类型和二级类型，之间用斜杠分隔。<br>除了预定义的类型，厂商也可以自定义类型。</p> <div class="language-http extra-class"><pre class="language-http"><code>application/vnd.debian.binary-package
</code></pre></div><p>上面的类型表明，发送的是Debian系统的二进制数据包。<br><code>MIME type</code>还可以在尾部使用分号，添加参数。</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">Content-Type:</span> text/html; charset=utf-8
</code></pre></div><p>上面的类型表明，发送的是网页，而且编码是UTF-8。<br>客户端请求的时候，可以使用<code>Accept</code>字段声明自己可以接受哪些数据格式。</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">Accept:</span> */*
</code></pre></div><p>上面代码中，客户端声明自己可以接受任何格式的数据。<br><code>MIME type</code>不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>Content-Type<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>text/html; charset=UTF-8<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!-- 等同于 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>utf-8<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span> 
</code></pre></div><p><a name="QflCh"></a></p> <h3 id="content-encoding-字段"><a href="#content-encoding-字段" aria-hidden="true" class="header-anchor">#</a> Content-Encoding 字段</h3> <p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。<code>Content-Encoding</code>字段说明数据的压缩方法。</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">Content-Encoding:</span> gzip
<span class="token header-name keyword">Content-Encoding:</span> compress
<span class="token header-name keyword">Content-Encoding:</span> deflate
</code></pre></div><p>客户端在请求时，用<code>Accept-Encoding</code>字段说明自己可以接受哪些压缩方法。</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">Accept-Encoding:</span> gzip, deflate
</code></pre></div><p><a name="Ho4Ze"></a></p> <h3 id="缺点"><a href="#缺点" aria-hidden="true" class="header-anchor">#</a> 缺点</h3> <p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。<br>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。<br>为了解决这个问题，有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">Connection:</span> keep-alive
</code></pre></div><p>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">Connection:</span> keep-alive
</code></pre></div><p>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p> <p><a name="bmbFw"></a></p> <h2 id="http-1-1"><a href="#http-1-1" aria-hidden="true" class="header-anchor">#</a> HTTP / 1.1</h2> <p>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</p> <ol><li>支持持久连接</li> <li>增加了管道机制（pipeline）</li> <li>支持的命令有：GET、POST、PUT、PATCH、HEAD、OPTIONS、DELETE</li> <li>请求头支持 Host 字段</li></ol> <p><a name="2qi2r"></a></p> <h3 id="持久连接"><a href="#持久连接" aria-hidden="true" class="header-anchor">#</a> 持久连接</h3> <p>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明 <code>Connection: keep-alive</code>。<br>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送 <code>Connection: close</code>，明确要求服务器关闭TCP连接。</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">Connection:</span> close
</code></pre></div><p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p> <p><a name="KfegF"></a></p> <h3 id="管道机制"><a href="#管道机制" aria-hidden="true" class="header-anchor">#</a> 管道机制</h3> <p>1.1 版还引入了管道机制（pipeline），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。<br>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p> <p><a name="579RQ"></a></p> <h3 id="content-length-字段"><a href="#content-length-字段" aria-hidden="true" class="header-anchor">#</a> Content-Length 字段</h3> <p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是<code>Content-length</code>字段的作用，声明本次回应的数据长度。</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">Content-Length:</span> 3495
</code></pre></div><p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。<br>在1.0版中，<code>Content-Length</code>字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p> <p><a name="sAO0T"></a></p> <h3 id="分块传输编码"><a href="#分块传输编码" aria-hidden="true" class="header-anchor">#</a> 分块传输编码</h3> <p>使用<code>Content-Length</code>字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。<br>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用&quot;流模式&quot;（stream）取代&quot;缓存模式&quot;（buffer）。<br>因此，1.1版规定可以不使用<code>Content-Length</code>字段，而使用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank" rel="noopener noreferrer">&quot;分块传输编码&quot;<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（chunked transfer encoding）。只要请求或回应的头信息有<code>Transfer-Encoding</code>字段，就表明回应将由数量未定的数据块组成。</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">Transfer-Encoding:</span> chunked
</code></pre></div><p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span>
<span class="token header-name keyword">Content-Type:</span> text/plain
<span class="token header-name keyword">Transfer-Encoding:</span> chunked

25
This is the data in the first chunk

1C
and this is the second one

3
con

8
sequence

0
</code></pre></div><p><a name="ImfLo"></a></p> <h3 id="其他"><a href="#其他" aria-hidden="true" class="header-anchor">#</a> 其他</h3> <p>1.1版还新增了许多动词方法：<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code>、 <code>OPTIONS</code>、<code>DELETE</code>。<br>另外，客户端请求的头信息新增了<code>Host</code>字段，用来指定服务器的域名。</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">Host:</span> www.example.com
</code></pre></div><p>有了<code>Host</code>字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p> <p><a name="zB2q9"></a></p> <h3 id="缺点-2"><a href="#缺点-2" aria-hidden="true" class="header-anchor">#</a> 缺点</h3> <p>虽然1.1版允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为<a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E" target="_blank" rel="noopener noreferrer">&quot;队头堵塞&quot;<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（Head-of-line blocking）。<br>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入 CSS 代码、域名分片（domain sharding）等等。如果 HTTP 协议设计得更好一些，这些额外的工作是可以避免的。</p> <p><a name="Kcumt"></a></p> <h2 id="http-2"><a href="#http-2" aria-hidden="true" class="header-anchor">#</a> HTTP / 2</h2> <p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。<a href="https://http2.github.io/http2-spec/" target="_blank" rel="noopener noreferrer">考古链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ol><li>所有数据以二进制传输</li> <li>同一个连接里发送多个请求不再需要按照顺序来</li> <li>头信息压缩以及推送等提高效率的功能</li></ol> <p><a name="Pv08v"></a></p> <h3 id="二进制协议"><a href="#二进制协议" aria-hidden="true" class="header-anchor">#</a> 二进制协议</h3> <p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为&quot;帧&quot;（frame）：头信息帧和数据帧。<br>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p> <p><a name="FAoNx"></a></p> <h3 id="多工"><a href="#多工" aria-hidden="true" class="header-anchor">#</a> 多工</h3> <p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了&quot;队头堵塞&quot;。<br>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。<br>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p> <p><a name="vRJap"></a></p> <h3 id="数据流"><a href="#数据流" aria-hidden="true" class="header-anchor">#</a> 数据流</h3> <p>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。<br>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。<br>数据流发送到一半的时候，客户端和服务器都可以发送信号（<code>RST_STREAM</code>帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。<br>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p> <p><a name="eNxm0"></a></p> <h3 id="头信息压缩"><a href="#头信息压缩" aria-hidden="true" class="header-anchor">#</a> 头信息压缩</h3> <p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如<code>Cookie</code>和<code>User Agent</code>，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。<br>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用<code>gzip</code>或<code>compress</code>压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p> <p><a name="eOwcW"></a></p> <h3 id="服务器推送"><a href="#服务器推送" aria-hidden="true" class="header-anchor">#</a> 服务器推送</h3> <p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。<br>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p> <p><a name="aA3WR"></a></p> <h2 id="参考链接"><a href="#参考链接" aria-hidden="true" class="header-anchor">#</a> 参考链接</h2> <ul><li><a href="https://blog.csdn.net/liujianfei526/article/details/53289350" target="_blank" rel="noopener noreferrer">HTTP 协议发展历史<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://blog.csdn.net/ccpat/article/details/79413433" target="_blank" rel="noopener noreferrer">HTTP协议漫谈 - HTTP协议历史和报文结构<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/learning-notes/http/TCPIP.html" class="prev">
          TCP/IP 五层模型
        </a></span> <span class="next"><a href="/learning-notes/http/HTTP-Connect.html">
          HTTP 三次握手和四次挥手
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/learning-notes/assets/js/app.2cc13775.js" defer></script><script src="/learning-notes/assets/js/9.d53e678f.js" defer></script>
  </body>
</html>
